name: 'Smart SSH Deploy Action'
description: 'Deploy only changed files to remote server via SSH with .gitignore support'
author: 'Baligs'
branding:
  icon: 'upload-cloud'
  color: 'blue'
inputs:
  server_ip:
    description: 'Server IP address'
    required: true
  username:
    description: 'SSH username'
    required: true
  private_key:
    description: 'SSH private key'
    required: true
  branch:
    description: 'Branch to deploy'
    required: false
    default: 'main'
  local_path:
    description: 'Local directory to deploy (relative to repo root)'
    required: false
    default: '.'
  remote_path:
    description: 'Remote directory path'
    required: true
  ssh_port:
    description: 'SSH port'
    required: false
    default: '22'
  exclude_files:
    description: 'Additional files to exclude (comma-separated)'
    required: false
    default: ''
  pre_deploy_commands:
    description: 'Commands to run before deployment (newline or semicolon separated)'
    required: false
    default: ''
  post_deploy_commands:
    description: 'Commands to run after deployment (newline or semicolon separated)'
    required: false
    default: ''
  working_directory:
    description: 'Working directory for pre-deploy commands'
    required: false
    default: '.'
  post_deploy_working_directory:
    description: 'Working directory for post-deploy commands'
    required: false
    default: '.'
  command_timeout:
    description: 'Timeout for pre-deploy commands (seconds)'
    required: false
    default: '300'
  post_deploy_timeout:
    description: 'Timeout for post-deploy commands (seconds)'
    required: false
    default: '300'
runs:
  using: 'composite'
  steps:
    - name: Setup SSH
      shell: bash
      run: |
        set -e
        echo "Setting up SSH connection..."
        
        # Create SSH directory
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Write private key
        echo "${{ inputs.private_key }}" > ~/.ssh/id_rsa
        
        # Fix potential line ending issues
        sed -i 's/\r$//' ~/.ssh/id_rsa
        
        # Ensure key has proper format
        if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/id_rsa; then
          echo "‚ùå Error: Private key does not appear to be in correct format"
          echo "Make sure your private key includes the full header and footer lines"
          exit 1
        fi
        
        if ! grep -q "END.*PRIVATE KEY" ~/.ssh/id_rsa; then
          echo "‚ùå Error: Private key appears to be incomplete"
          echo "Make sure your private key includes the full header and footer lines"
          exit 1
        fi
        
        # Set proper permissions
        chmod 600 ~/.ssh/id_rsa
        
        # Validate key format
        echo "Validating SSH key format..."
        if ! ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub 2>/dev/null; then
          echo "‚ùå Error: SSH private key is invalid or corrupted"
          echo "Please check your private key format and ensure it's not encrypted with a passphrase"
          exit 1
        fi
        
        echo "‚úÖ SSH key validation successful"
        
        # Create SSH config for better connection handling
        cat > ~/.ssh/config << EOF
        Host deploy_target
          HostName ${{ inputs.server_ip }}
          User ${{ inputs.username }}
          Port ${{ inputs.ssh_port }}
          IdentityFile ~/.ssh/id_rsa
          StrictHostKeyChecking no
          UserKnownHostsFile /dev/null
          ConnectTimeout 30
          ServerAliveInterval 10
          ServerAliveCountMax 3
        EOF
        
        # Test SSH connection
        echo "Testing SSH connection..."
        if ssh deploy_target "echo 'SSH connection test successful'" 2>/dev/null; then
          echo "‚úÖ SSH connection test passed"
        else
          echo "‚ùå SSH connection failed. Please check:"
          echo "  - Server IP: ${{ inputs.server_ip }}"
          echo "  - Username: ${{ inputs.username }}"
          echo "  - SSH Port: ${{ inputs.ssh_port }}"
          echo "  - Make sure the public key is installed on the server"
          echo "  - Make sure SSH key authentication is enabled on the server"
          exit 1
        fi
        
    - name: Install dependencies
      shell: bash
      run: |
        sudo apt-get update
        sudo apt-get install -y rsync
        
    - name: Setup deployment tracking
      shell: bash
      run: |
        set -e
        echo "Setting up deployment tracking..."
        
        # Create deployment directory
        mkdir -p .deploy-action
        
        # Get current commit hash
        CURRENT_COMMIT=$(git rev-parse HEAD)
        echo "CURRENT_COMMIT=$CURRENT_COMMIT" >> $GITHUB_ENV
        echo "Current commit: $CURRENT_COMMIT"
        
        # Try to get last deployed commit from remote
        LAST_COMMIT=""
        echo "Checking for previous deployment..."
        if ssh deploy_target "test -f ${{ inputs.remote_path }}/.last-deploy-commit" 2>/dev/null; then
          LAST_COMMIT=$(ssh deploy_target "cat ${{ inputs.remote_path }}/.last-deploy-commit" 2>/dev/null || echo "")
          echo "Last deployed commit: $LAST_COMMIT"
        else
          echo "No previous deployment found, will deploy all files"
        fi
        
        echo "LAST_COMMIT=$LAST_COMMIT" >> $GITHUB_ENV
        
    - name: Run pre-deploy commands
      shell: bash
      run: |
        if [ -n "${{ inputs.pre_deploy_commands }}" ]; then
          echo "üîß Running pre-deploy commands..."
          
          # Change to working directory
          cd ${{ inputs.working_directory }}
          echo "Working directory: $(pwd)"
          
          # Parse commands (support both newline and semicolon separation)
          COMMANDS=$(echo "${{ inputs.pre_deploy_commands }}" | tr ';' '\n' | grep -v '^[[:space:]]*$')
          
          # Execute each command
          echo "$COMMANDS" | while IFS= read -r cmd; do
            if [ -n "$cmd" ]; then
              echo "‚ñ∂Ô∏è Executing: $cmd"
              
              # Run command with timeout
              if timeout ${{ inputs.command_timeout }} bash -c "$cmd"; then
                echo "‚úÖ Command completed successfully"
              else
                exit_code=$?
                if [ $exit_code -eq 124 ]; then
                  echo "‚ùå Command timed out after ${{ inputs.command_timeout }} seconds"
                  exit 1
                else
                  echo "‚ùå Command failed with exit code: $exit_code"
                  exit $exit_code
                fi
              fi
              echo ""
            fi
          done
          
          echo "‚úÖ All pre-deploy commands completed successfully"
        else
          echo "No pre-deploy commands specified"
        fi
        
    - name: Generate file list
      shell: bash
      run: |
        set -e
        echo "Generating list of files to deploy..."
        
        cd ${{ inputs.local_path }}
        
        # Ensure .deploy-action directory exists
        mkdir -p .deploy-action
        
        # Create .deployignore from .gitignore if it exists
        if [ -f .gitignore ]; then
          cp .gitignore .deploy-action/.deployignore
        else
          touch .deploy-action/.deployignore
        fi
        
        # Add additional excludes
        echo ".git/" >> .deploy-action/.deployignore
        echo ".github/" >> .deploy-action/.deployignore
        echo ".deploy-action/" >> .deploy-action/.deployignore
        echo ".last-deploy-commit" >> .deploy-action/.deployignore
        
        # Add user-specified excludes
        if [ -n "${{ inputs.exclude_files }}" ]; then
          IFS=',' read -ra EXCLUDES <<< "${{ inputs.exclude_files }}"
          for exclude in "${EXCLUDES[@]}"; do
            echo "$exclude" >> .deploy-action/.deployignore
          done
        fi
        
        # Generate list of changed files
        if [ -n "$LAST_COMMIT" ] && [ "$LAST_COMMIT" != "$CURRENT_COMMIT" ]; then
          echo "Getting changed files between $LAST_COMMIT and $CURRENT_COMMIT"
          
          # Get changed, added, and modified files
          git diff --name-only --diff-filter=ACM $LAST_COMMIT $CURRENT_COMMIT > .deploy-action/changed-files.txt
          
          # Get deleted files
          git diff --name-only --diff-filter=D $LAST_COMMIT $CURRENT_COMMIT > .deploy-action/deleted-files.txt
          
          echo "Changed files:"
          cat .deploy-action/changed-files.txt
          
          echo "Deleted files:"
          cat .deploy-action/deleted-files.txt
          
        else
          echo "First deployment or same commit, deploying all files"
          # Find all files, excluding ignored ones
          find . -type f | grep -v -f .deploy-action/.deployignore > .deploy-action/changed-files.txt 2>/dev/null || find . -type f > .deploy-action/changed-files.txt
          touch .deploy-action/deleted-files.txt
        fi
        
        # Filter changed files through .deployignore
        if [ -s .deploy-action/changed-files.txt ]; then
          grep -v -f .deploy-action/.deployignore .deploy-action/changed-files.txt > .deploy-action/filtered-files.txt 2>/dev/null || touch .deploy-action/filtered-files.txt
          mv .deploy-action/filtered-files.txt .deploy-action/changed-files.txt
        fi
        
        echo "Files to deploy:"
        cat .deploy-action/changed-files.txt
        
        # Count files
        CHANGED_COUNT=$(wc -l < .deploy-action/changed-files.txt)
        DELETED_COUNT=$(wc -l < .deploy-action/deleted-files.txt)
        
        echo "CHANGED_COUNT=$CHANGED_COUNT" >> $GITHUB_ENV
        echo "DELETED_COUNT=$DELETED_COUNT" >> $GITHUB_ENV
        
    - name: Create remote directory
      shell: bash
      run: |
        set -e
        echo "Ensuring remote directory exists..."
        ssh deploy_target "mkdir -p ${{ inputs.remote_path }}"
        echo "‚úÖ Remote directory ready"
            
    - name: Deploy changed files
      shell: bash
      run: |
        set -e
        if [ "$CHANGED_COUNT" -gt 0 ]; then
          echo "Deploying $CHANGED_COUNT changed files..."
          
          cd ${{ inputs.local_path }}
          
          # Create tar of changed files
          tar -czf .deploy-action/deploy.tar.gz -T .deploy-action/changed-files.txt
          
          # Copy tar to remote
          scp .deploy-action/deploy.tar.gz deploy_target:${{ inputs.remote_path }}/
          
          # Extract on remote
          ssh deploy_target "cd ${{ inputs.remote_path }} && tar -xzf deploy.tar.gz && rm deploy.tar.gz"
              
          echo "‚úÖ Successfully deployed $CHANGED_COUNT files"
        else
          echo "No files to deploy"
        fi
        
    - name: Remove deleted files
      shell: bash
      run: |
        set -e
        if [ "$DELETED_COUNT" -gt 0 ]; then
          echo "Removing $DELETED_COUNT deleted files..."
          
          cd ${{ inputs.local_path }}
          
          # Remove deleted files from remote
          while IFS= read -r file; do
            if [ -n "$file" ]; then
              echo "Removing: $file"
              ssh deploy_target "rm -f ${{ inputs.remote_path }}/$file"
            fi
          done < .deploy-action/deleted-files.txt
          
          echo "‚úÖ Successfully removed $DELETED_COUNT files"
        else
          echo "No files to remove"
        fi
        
    - name: Update deployment tracking
      shell: bash
      run: |
        set -e
        echo "Updating deployment tracking..."
        
        # Save current commit hash on remote
        ssh deploy_target "echo '$CURRENT_COMMIT' > ${{ inputs.remote_path }}/.last-deploy-commit"
            
        echo "‚úÖ Deployment completed successfully!"
        echo "üìä Deployed: $CHANGED_COUNT files"
        echo "üóëÔ∏è Removed: $DELETED_COUNT files"
        echo "üîó Commit: $CURRENT_COMMIT"
        
    - name: Run post-deploy commands
      shell: bash
      run: |
        if [ -n "${{ inputs.post_deploy_commands }}" ]; then
          echo "üöÄ Running post-deploy commands..."
          
          # Change to working directory
          cd ${{ inputs.post_deploy_working_directory }}
          echo "Working directory: $(pwd)"
          
          # Parse commands (support both newline and semicolon separation)
          COMMANDS=$(echo "${{ inputs.post_deploy_commands }}" | tr ';' '\n' | grep -v '^[[:space:]]*$')
          
          # Execute each command
          echo "$COMMANDS" | while IFS= read -r cmd; do
            if [ -n "$cmd" ]; then
              echo "‚ñ∂Ô∏è Executing: $cmd"
              
              # Run command with timeout
              if timeout ${{ inputs.post_deploy_timeout }} bash -c "$cmd"; then
                echo "‚úÖ Post-deploy command completed successfully"
              else
                exit_code=$?
                if [ $exit_code -eq 124 ]; then
                  echo "‚ö†Ô∏è Post-deploy command timed out after ${{ inputs.post_deploy_timeout }} seconds"
                  echo "Warning: Deployment was successful but post-deploy command failed"
                  exit 0  # Don't fail the entire deployment for post-deploy failures
                else
                  echo "‚ö†Ô∏è Post-deploy command failed with exit code: $exit_code"
                  echo "Warning: Deployment was successful but post-deploy command failed"
                  exit 0  # Don't fail the entire deployment for post-deploy failures
                fi
              fi
              echo ""
            fi
          done
          
          echo "‚úÖ All post-deploy commands completed"
        else
          echo "No post-deploy commands specified"
        fi
        
    - name: Cleanup
      shell: bash
      if: always()
      run: |
        rm -rf ~/.ssh/id_rsa ~/.ssh/id_rsa.pub ~/.ssh/config
        rm -rf .deploy-action